package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"

	"github.com/mitchellh/mapstructure"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"open-btm.com/common"
	"open-btm.com/graph/model"
	"open-btm.com/models"
)

// Createsprint is the resolver for the createsprint field.
func (r *mutationResolver) Createsprint(ctx context.Context, input model.CreateSprintInput) (*model.Sprint, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//created sprint initalization
	create_sprint := new(model.Sprint)

	//  initiate -> sprint
	sprint := new(models.Sprint)
	sprint.Name = input.Name
	sprint.Description = input.Description

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add sprint using transaction if values are valid
	if err := tx.Create(&sprint).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(sprint, &create_sprint); err != nil {
		return nil, err
	}
	return create_sprint, nil
}

// Updatesprint is the resolver for the updatesprint field.
func (r *mutationResolver) Updatesprint(ctx context.Context, input model.UpdateSprintInput) (*model.Sprint, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// updated up for return if transaction success
	update_sprint := new(model.Sprint)

	// startng update transaction
	var sprint models.Sprint

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", uint(input.ID)).First(&sprint).Error; err != nil {
		return nil, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add sprint using transaction if values are valid
	if err := tx.Model(&sprint).UpdateColumns(*&input).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(sprint, &update_sprint); err != nil {
		return nil, err
	}
	return update_sprint, nil
}

// Deletesprint is the resolver for the deletesprint field.
func (r *mutationResolver) Deletesprint(ctx context.Context, id uint) (bool, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// startng update transaction
	var sprint models.Sprint

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", uint(id)).First(&sprint).Error; err != nil {
		return false, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// delete sprint using transaction if values are valid
	if err := db.Delete(&sprint).Error; err != nil {
		tx.Rollback()
		return false, err
	}
	// close transaction
	tx.Commit()

	return true, nil
}

// Createrequirementsprint is the resolver for the createrequirementsprint field.
func (r *mutationResolver) Createrequirementsprint(ctx context.Context, requirementID uint, sprintID uint) (*model.Requirement, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//sprint_requirement for return if transaction success
	sprint_requirement := new(model.Requirement)

	// updateing requirement transaction
	var sprint models.Sprint

	// Check if the sprint record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", sprintID).First(&sprint).Error; err != nil {
		return nil, err
	}
	// Check if the requirement record exists
	var requirement models.Requirement
	if res := db.WithContext(tracer.Tracer).Model(&models.Requirement{}).Where("id = ?", requirementID).First(&requirement); res.Error != nil {
		return nil, res.Error
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add requirement to sprint data using transaction if values are valid
	if err := db.WithContext(tracer.Tracer).Model(&sprint).Association("Requirements").Append(&requirement); err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(requirement, &sprint_requirement); err != nil {
		return nil, err
	}
	return sprint_requirement, nil
}

// Deleterequirementsprint is the resolver for the deleterequirementsprint field.
func (r *mutationResolver) Deleterequirementsprint(ctx context.Context, requirementID uint, sprintID uint) (*model.Requirement, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//sprint_requirement for return if transaction success
	sprint_requirement := new(model.Requirement)

	// updateing requirement transaction
	var sprint models.Sprint

	// Check if the sprint record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", sprintID).First(&sprint).Error; err != nil {
		return nil, err
	}

	// Check if the requirement record exists
	var requirement models.Requirement
	if res := db.WithContext(tracer.Tracer).Model(&models.Requirement{}).Where("id = ?", requirementID).First(&requirement); res.Error != nil {
		return nil, res.Error
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// delete  data using transaction if values are valid
	if err := db.WithContext(tracer.Tracer).Model(&sprint).Association("Requirements").Delete(&requirement); err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(requirement, &sprint_requirement); err != nil {
		return nil, err
	}
	return sprint_requirement, nil
}

// Createrequirement is the resolver for the createrequirement field.
func (r *mutationResolver) Createrequirement(ctx context.Context, input model.CreateRequirementInput) (*model.Requirement, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//created requirement initalization
	create_requirement := new(model.Requirement)

	//  initiate -> requirement
	requirement := new(models.Requirement)
	requirement.Name = input.Name
	requirement.Description = input.Description

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add requirement using transaction if values are valid
	if err := tx.Create(&requirement).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(requirement, &create_requirement); err != nil {
		return nil, err
	}
	return create_requirement, nil
}

// Updaterequirement is the resolver for the updaterequirement field.
func (r *mutationResolver) Updaterequirement(ctx context.Context, input model.UpdateRequirementInput) (*model.Requirement, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// updated up for return if transaction success
	update_requirement := new(model.Requirement)

	// startng update transaction
	var requirement models.Requirement

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", uint(input.ID)).First(&requirement).Error; err != nil {
		return nil, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add requirement using transaction if values are valid
	if err := tx.Model(&requirement).UpdateColumns(*&input).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(requirement, &update_requirement); err != nil {
		return nil, err
	}
	return update_requirement, nil
}

// Deleterequirement is the resolver for the deleterequirement field.
func (r *mutationResolver) Deleterequirement(ctx context.Context, id uint) (bool, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// startng update transaction
	var requirement models.Requirement

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", uint(id)).First(&requirement).Error; err != nil {
		return false, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// delete requirement using transaction if values are valid
	if err := db.Delete(&requirement).Error; err != nil {
		tx.Rollback()
		return false, err
	}
	// close transaction
	tx.Commit()

	return true, nil
}

// Createtest is the resolver for the createtest field.
func (r *mutationResolver) Createtest(ctx context.Context, input model.CreateTestInput) (*model.Test, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//created test initalization
	create_test := new(model.Test)

	//  initiate -> test
	test := new(models.Test)
	test.Name = input.Name
	test.Steps = input.Steps
	test.ExpectedResult = input.Expectedresult

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add test using transaction if values are valid
	if err := tx.Create(&test).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(test, &create_test); err != nil {
		return nil, err
	}
	return create_test, nil
}

// Updatetest is the resolver for the updatetest field.
func (r *mutationResolver) Updatetest(ctx context.Context, input model.UpdateTestInput) (*model.Test, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// updated up for return if transaction success
	update_test := new(model.Test)

	// startng update transaction
	var test models.Test

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", uint(input.ID)).First(&test).Error; err != nil {
		return nil, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add test using transaction if values are valid
	if err := tx.Model(&test).UpdateColumns(*&input).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(test, &update_test); err != nil {
		return nil, err
	}
	return update_test, nil
}

// Deletetest is the resolver for the deletetest field.
func (r *mutationResolver) Deletetest(ctx context.Context, id uint) (bool, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// startng update transaction
	var test models.Test

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", uint(id)).First(&test).Error; err != nil {
		return false, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// delete test using transaction if values are valid
	if err := db.Delete(&test).Error; err != nil {
		tx.Rollback()
		return false, err
	}
	// close transaction
	tx.Commit()

	return true, nil
}

// Createtestset is the resolver for the createtestset field.
func (r *mutationResolver) Createtestset(ctx context.Context, input model.CreateTestsetInput) (*model.Testset, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//created testset initalization
	create_testset := new(model.Testset)

	//  initiate -> testset
	testset := new(models.Testset)
	testset.Name = input.Name
	testset.Description = input.Description

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add testset using transaction if values are valid
	if err := tx.Create(&testset).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(testset, &create_testset); err != nil {
		return nil, err
	}
	return create_testset, nil
}

// Updatetestset is the resolver for the updatetestset field.
func (r *mutationResolver) Updatetestset(ctx context.Context, input model.UpdateTestsetInput) (*model.Testset, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// updated up for return if transaction success
	update_testset := new(model.Testset)

	// startng update transaction
	var testset models.Testset

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", uint(input.ID)).First(&testset).Error; err != nil {
		return nil, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add testset using transaction if values are valid
	if err := tx.Model(&testset).UpdateColumns(*&input).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(testset, &update_testset); err != nil {
		return nil, err
	}
	return update_testset, nil
}

// Deletetestset is the resolver for the deletetestset field.
func (r *mutationResolver) Deletetestset(ctx context.Context, id uint) (bool, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// startng update transaction
	var testset models.Testset

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", uint(id)).First(&testset).Error; err != nil {
		return false, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// delete testset using transaction if values are valid
	if err := db.Delete(&testset).Error; err != nil {
		tx.Rollback()
		return false, err
	}
	// close transaction
	tx.Commit()

	return true, nil
}

// Createtesttestset is the resolver for the createtesttestset field.
func (r *mutationResolver) Createtesttestset(ctx context.Context, testID uint, testsetID uint) (*model.Test, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//testset_test for return if transaction success
	testset_test := new(model.Test)

	// updateing test transaction
	var testset models.Testset

	// Check if the testset record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", testsetID).First(&testset).Error; err != nil {
		return nil, err
	}
	// Check if the test record exists
	var test models.Test
	if res := db.WithContext(tracer.Tracer).Model(&models.Test{}).Where("id = ?", testID).First(&test); res.Error != nil {
		return nil, res.Error
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add test to testset data using transaction if values are valid
	if err := db.WithContext(tracer.Tracer).Model(&testset).Association("Tests").Append(&test); err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(test, &testset_test); err != nil {
		return nil, err
	}
	return testset_test, nil
}

// Deletetesttestset is the resolver for the deletetesttestset field.
func (r *mutationResolver) Deletetesttestset(ctx context.Context, testID uint, testsetID uint) (*model.Test, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//testset_test for return if transaction success
	testset_test := new(model.Test)

	// updateing test transaction
	var testset models.Testset

	// Check if the testset record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", testsetID).First(&testset).Error; err != nil {
		return nil, err
	}

	// Check if the test record exists
	var test models.Test
	if res := db.WithContext(tracer.Tracer).Model(&models.Test{}).Where("id = ?", testID).First(&test); res.Error != nil {
		return nil, res.Error
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// delete  data using transaction if values are valid
	if err := db.WithContext(tracer.Tracer).Model(&testset).Association("Tests").Delete(&test); err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(test, &testset_test); err != nil {
		return nil, err
	}
	return testset_test, nil
}

// Updatetesttestset is the resolver for the updatetesttestset field.
func (r *mutationResolver) Updatetesttestset(ctx context.Context, input model.UpdateTestTestsetInput) (*model.TestTestset, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// updated up for return if transaction success
	update_testtestset := new(model.TestTestset)

	// startng update transaction
	var testtestset models.TestTestset

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", uint(input.ID)).First(&testtestset).Error; err != nil {
		return nil, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add testtestset using transaction if values are valid
	if err := tx.Model(&testtestset).UpdateColumns(*&input).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(testtestset, &update_testtestset); err != nil {
		return nil, err
	}
	return update_testtestset, nil
}

// Createissuetesttestset is the resolver for the createissuetesttestset field.
func (r *mutationResolver) Createissuetesttestset(ctx context.Context, issueID uint, testTestsetID uint) (*model.Issue, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//testtestset_issue for return if transaction success
	testtestset_issue := new(model.Issue)

	// updateing issue transaction
	var testtestset models.TestTestset

	// Check if the testtestset record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", testTestsetID).First(&testtestset).Error; err != nil {
		return nil, err
	}
	// Check if the issue record exists
	var issue models.Issue
	if res := db.WithContext(tracer.Tracer).Model(&models.Issue{}).Where("id = ?", issueID).First(&issue); res.Error != nil {
		return nil, res.Error
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add issue to testtestset data using transaction if values are valid
	if err := db.WithContext(tracer.Tracer).Model(&testtestset).Association("Issues").Append(&issue); err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(issue, &testtestset_issue); err != nil {
		return nil, err
	}
	return testtestset_issue, nil
}

// Deleteissuetesttestset is the resolver for the deleteissuetesttestset field.
func (r *mutationResolver) Deleteissuetesttestset(ctx context.Context, issueID uint, testTestsetID uint) (*model.Issue, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//testtestset_issue for return if transaction success
	testtestset_issue := new(model.Issue)

	// updateing issue transaction
	var testtestset models.TestTestset
	testtestset.ID = testTestsetID

	// Check if the testtestset record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", testTestsetID).First(&testtestset).Error; err != nil {
		return nil, err
	}

	// Check if the issue record exists
	var issue models.Issue
	if res := db.WithContext(tracer.Tracer).Model(&models.Issue{}).Where("id = ?", issueID).First(&issue); res.Error != nil {
		return nil, res.Error
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// delete  data using transaction if values are valid
	if err := db.WithContext(tracer.Tracer).Model(&testtestset).Association("Issues").Delete(&issue); err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(issue, &testtestset_issue); err != nil {
		return nil, err
	}
	return testtestset_issue, nil
}

// Createissue is the resolver for the createissue field.
func (r *mutationResolver) Createissue(ctx context.Context, input model.CreateIssueInput) (*model.Issue, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//created issue initalization
	create_issue := new(model.Issue)

	//  initiate -> issue
	issue := new(models.Issue)
	issue.IssueName = input.IssueName
	issue.IssueDescription = input.IssueDescription
	issue.IssueStatus = input.IssueStatus.String()

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add issue using transaction if values are valid
	if err := tx.Create(&issue).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(issue, &create_issue); err != nil {
		return nil, err
	}
	return create_issue, nil
}

// Updateissue is the resolver for the updateissue field.
func (r *mutationResolver) Updateissue(ctx context.Context, input model.UpdateIssueInput) (*model.Issue, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// updated up for return if transaction success
	update_issue := new(model.Issue)

	// startng update transaction
	var issue models.Issue

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", uint(input.ID)).First(&issue).Error; err != nil {
		return nil, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add issue using transaction if values are valid
	if err := tx.Model(&issue).UpdateColumns(*&input).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(issue, &update_issue); err != nil {
		return nil, err
	}
	return update_issue, nil
}

// Deleteissue is the resolver for the deleteissue field.
func (r *mutationResolver) Deleteissue(ctx context.Context, id uint) (bool, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// startng update transaction
	var issue models.Issue

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).Where("id = ?", uint(id)).First(&issue).Error; err != nil {
		return false, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// delete issue using transaction if values are valid
	if err := db.Delete(&issue).Error; err != nil {
		tx.Rollback()
		return false, err
	}
	// close transaction
	tx.Commit()

	return true, nil
}

// Sprints is the resolver for getting list of sprints field.
func (r *queryResolver) Sprints(ctx context.Context, page uint, size uint) ([]*model.Sprint, error) {
	db := r.DB         // Database session for querying
	tracer := r.Tracer // otel collector context and span

	sprint_get := make([]*model.Sprint, 0)
	_, result, err := common.PaginationPureModel(db, models.Sprint{}, []models.Sprint{}, uint(page), uint(size), tracer.Tracer)
	if err != nil {
		return nil, err
	}
	sprint := result.([]models.Sprint)

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(sprint, &sprint_get); err != nil {
		return nil, err
	}
	return sprint_get, nil
}

// Sprint is the resolver for single sprint field.
func (r *queryResolver) Sprint(ctx context.Context, id uint) (*model.Sprint, error) {
	db := r.DB         // database connection
	tracer := r.Tracer //otel tracer span and context

	var sprint models.Sprint    // SQL GORM model
	var sprint_get model.Sprint // graphql model

	if res := db.WithContext(tracer.Tracer).Model(&models.Sprint{}).Preload(clause.Associations).Where("id = ?", uint(id)).First(&sprint); res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, res.Error
		}
		return nil, res.Error
	}

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(sprint, &sprint_get); err != nil {
		return nil, err
	}

	return &sprint_get, nil
}

// Sprintrequirements is the resolver for the getting sprintrequirements field.
func (r *queryResolver) Sprintrequirements(ctx context.Context, requirementID uint, sprintID uint, page uint, size uint) ([]*model.Requirement, error) {
	db := r.DB
	tracer := r.Tracer
	requirement_get := make([]*model.Requirement, 0)
	_, result, err := common.PaginationPureModelFilterOneToMany(db, models.Requirement{}, []models.Requirement{}, "sprint_id = ?", uint(sprintID), uint(page), uint(size), tracer.Tracer)
	if err != nil {
		return nil, err
	}
	requirement := result.([]models.Requirement)

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(requirement, &requirement_get); err != nil {
		return nil, err
	}

	return requirement_get, nil
}

// Requirements is the resolver for getting list of requirements field.
func (r *queryResolver) Requirements(ctx context.Context, page uint, size uint) ([]*model.Requirement, error) {
	db := r.DB         // Database session for querying
	tracer := r.Tracer // otel collector context and span

	requirement_get := make([]*model.Requirement, 0)
	_, result, err := common.PaginationPureModel(db, models.Requirement{}, []models.Requirement{}, uint(page), uint(size), tracer.Tracer)
	if err != nil {
		return nil, err
	}
	requirement := result.([]models.Requirement)

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(requirement, &requirement_get); err != nil {
		return nil, err
	}
	return requirement_get, nil
}

// Requirement is the resolver for single requirement field.
func (r *queryResolver) Requirement(ctx context.Context, id uint) (*model.Requirement, error) {
	db := r.DB         // database connection
	tracer := r.Tracer //otel tracer span and context

	var requirement models.Requirement    // SQL GORM model
	var requirement_get model.Requirement // graphql model

	if res := db.WithContext(tracer.Tracer).Model(&models.Requirement{}).Preload(clause.Associations).Where("id = ?", uint(id)).First(&requirement); res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, res.Error
		}
		return nil, res.Error
	}

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(requirement, &requirement_get); err != nil {
		return nil, err
	}

	return &requirement_get, nil
}

// Tests is the resolver for getting list of tests field.
func (r *queryResolver) Tests(ctx context.Context, page uint, size uint) ([]*model.Test, error) {
	db := r.DB         // Database session for querying
	tracer := r.Tracer // otel collector context and span

	test_get := make([]*model.Test, 0)
	_, result, err := common.PaginationPureModel(db, models.Test{}, []models.Test{}, uint(page), uint(size), tracer.Tracer)
	if err != nil {
		return nil, err
	}
	test := result.([]models.Test)

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(test, &test_get); err != nil {
		return nil, err
	}
	return test_get, nil
}

// Test is the resolver for single test field.
func (r *queryResolver) Test(ctx context.Context, id uint) (*model.Test, error) {
	db := r.DB         // database connection
	tracer := r.Tracer //otel tracer span and context

	var test models.Test    // SQL GORM model
	var test_get model.Test // graphql model

	if res := db.WithContext(tracer.Tracer).Model(&models.Test{}).Preload(clause.Associations).Where("id = ?", uint(id)).First(&test); res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, res.Error
		}
		return nil, res.Error
	}

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(test, &test_get); err != nil {
		return nil, err
	}

	return &test_get, nil
}

// Testsets is the resolver for getting list of testsets field.
func (r *queryResolver) Testsets(ctx context.Context, page uint, size uint) ([]*model.Testset, error) {
	db := r.DB         // Database session for querying
	tracer := r.Tracer // otel collector context and span

	testset_get := make([]*model.Testset, 0)
	_, result, err := common.PaginationPureModel(db, models.Testset{}, []models.Testset{}, uint(page), uint(size), tracer.Tracer)
	if err != nil {
		return nil, err
	}
	testset := result.([]models.Testset)

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(testset, &testset_get); err != nil {
		return nil, err
	}
	return testset_get, nil
}

// Testset is the resolver for single testset field.
func (r *queryResolver) Testset(ctx context.Context, id uint) (*model.Testset, error) {
	db := r.DB         // database connection
	tracer := r.Tracer //otel tracer span and context

	var testset models.Testset    // SQL GORM model
	var testset_get model.Testset // graphql model

	if res := db.WithContext(tracer.Tracer).Model(&models.Testset{}).Preload(clause.Associations).Where("id = ?", uint(id)).First(&testset); res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, res.Error
		}
		return nil, res.Error
	}

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(testset, &testset_get); err != nil {
		return nil, err
	}

	return &testset_get, nil
}

// Testsettests is the resolver for the getting testsettests field.
func (r *queryResolver) Testsettests(ctx context.Context, testID uint, testsetID uint, page uint, size uint) ([]*model.Test, error) {
	db := r.DB
	tracer := r.Tracer
	tests_get := make([]*model.Test, 0)
	join_string := "INNER JOIN testset_tests ur ON tests.id = ur.test_id"
	filter_string := "testset_id = ?"

	//  to make sure no more that 50 items will be queried per request
	if size > 50 {
		size = 50
	}

	// dry run testing join query
	tests := []models.Test{}
	if err := db.WithContext(tracer.Tracer).Model(&models.Test{}).Joins(join_string).Where(filter_string, testsetID).Order("id asc").Limit(int(size)).Offset(int(page - 1)).Find(&tests); err != nil {
		return nil, err.Error
	}

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(tests, &tests_get); err != nil {
		return nil, err
	}

	return tests_get, nil
}

// Testtestsets is the resolver for the testtestsets field.
func (r *queryResolver) Testtestsets(ctx context.Context, page uint, size uint) ([]*model.TestTestset, error) {
	db := r.DB         // Database session for querying
	tracer := r.Tracer // otel collector context and span

	testtestset_get := make([]*model.TestTestset, 0)
	_, result, err := common.PaginationPureModel(db, models.TestTestset{}, []models.TestTestset{}, uint(page), uint(size), tracer.Tracer)
	if err != nil {
		return nil, err
	}
	testtestset := result.([]models.TestTestset)

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(testtestset, &testtestset_get); err != nil {
		return nil, err
	}
	return testtestset_get, nil
}

// Testtestset is the resolver for the testtestset field.
func (r *queryResolver) Testtestset(ctx context.Context, id uint) (*model.TestTestset, error) {
	db := r.DB         // database connection
	tracer := r.Tracer //otel tracer span and context

	var testtestset models.TestTestset    // SQL GORM model
	var testtestset_get model.TestTestset // graphql model

	if res := db.WithContext(tracer.Tracer).Model(&models.TestTestset{}).Preload(clause.Associations).Where("id = ?", uint(id)).First(&testtestset); res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, res.Error
		}
		return nil, res.Error
	}

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(testtestset, &testtestset_get); err != nil {
		return nil, err
	}

	return &testtestset_get, nil
}

// TestTestsetissues is the resolver for the getting testtestsetissues field.
func (r *queryResolver) Testtestsetissues(ctx context.Context, issueID uint, testTestsetID uint, page uint, size uint) ([]*model.Issue, error) {
	db := r.DB
	tracer := r.Tracer
	issues_get := make([]*model.Issue, 0)
	join_string := "INNER JOIN testtestset_issues ur ON issues.id = ur.issue_id"
	filter_string := "testtestset_id = ?"

	//  to make sure no more that 50 items will be queried per request
	if size > 50 {
		size = 50
	}

	// dry run testing join query
	issues := []models.Issue{}
	if err := db.WithContext(tracer.Tracer).Model(&models.Issue{}).Joins(join_string).Where(filter_string, testTestsetID).Order("id asc").Limit(int(size)).Offset(int(page - 1)).Find(&issues); err != nil {
		return nil, err.Error
	}

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(issues, &issues_get); err != nil {
		return nil, err
	}

	return issues_get, nil
}

// Issues is the resolver for getting list of issues field.
func (r *queryResolver) Issues(ctx context.Context, page uint, size uint) ([]*model.Issue, error) {
	db := r.DB         // Database session for querying
	tracer := r.Tracer // otel collector context and span

	issue_get := make([]*model.Issue, 0)
	_, result, err := common.PaginationPureModel(db, models.Issue{}, []models.Issue{}, uint(page), uint(size), tracer.Tracer)
	if err != nil {
		return nil, err
	}
	issue := result.([]models.Issue)

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(issue, &issue_get); err != nil {
		return nil, err
	}
	return issue_get, nil
}

// Issue is the resolver for single issue field.
func (r *queryResolver) Issue(ctx context.Context, id uint) (*model.Issue, error) {
	db := r.DB         // database connection
	tracer := r.Tracer //otel tracer span and context

	var issue models.Issue    // SQL GORM model
	var issue_get model.Issue // graphql model

	if res := db.WithContext(tracer.Tracer).Model(&models.Issue{}).Preload(clause.Associations).Where("id = ?", uint(id)).First(&issue); res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, res.Error
		}
		return nil, res.Error
	}

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(issue, &issue_get); err != nil {
		return nil, err
	}

	return &issue_get, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
