package users

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"fmt"

	"github.com/mitchellh/mapstructure"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"open-btm.com/common"
	"open-btm.com/database"
	"open-btm.com/models"
	"open-btm.com/users/model"
)

// Createproject is the resolver for the createproject field.
func (r *mutationResolver) Createproject(ctx context.Context, input model.CreateProjectInput) (*model.Project, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	//created project initalization
	create_project := new(model.Project)

	//  initiate -> project
	project := new(models.Project)
	project.Name = input.Name
	project.Description = input.Description

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add project using transaction if values are valid
	if err := tx.Create(&project).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	tx.Commit()
	// close transaction

	_, err := database.CreateDatabase(project.DatabaseName)
	if err != nil {
		return nil, fmt.Errorf("Error Creating Project Database: %v", err)
	}

	models.MigrateToPojectDatabase(project.DatabaseName)

	if err := mapstructure.Decode(project, &create_project); err != nil {
		return nil, err
	}

	return create_project, nil
}

// Updateproject is the resolver for the updateproject field.
func (r *mutationResolver) Updateproject(ctx context.Context, input model.UpdateProjectInput) (*model.Project, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// updated up for return if transaction success
	update_project := new(model.Project)

	// startng update transaction
	var project models.Project
	project.ID = uint(input.ID)

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).First(&project, project.ID).Error; err != nil {
		return nil, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// add project using transaction if values are valid
	if err := tx.Model(&project).UpdateColumns(*&input).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	// close transaction
	tx.Commit()

	if err := mapstructure.Decode(project, &update_project); err != nil {
		return nil, err
	}
	return update_project, nil
}

// Deleteproject is the resolver for the deleteproject field.
func (r *mutationResolver) Deleteproject(ctx context.Context, id uint) (bool, error) {
	db := r.DB         // databse connection
	tracer := r.Tracer // otel jaeger tracer

	// startng update transaction
	var project models.Project
	project.ID = uint(id)

	// Check if the record exists
	if err := db.WithContext(tracer.Tracer).First(&project, project.ID).Error; err != nil {
		return false, err
	}

	//  start transaction to database
	tx := db.WithContext(tracer.Tracer).Begin()

	// delete project using transaction if values are valid
	if err := db.Delete(&project).Error; err != nil {
		tx.Rollback()
		return false, err
	}
	// close transaction
	tx.Commit()

	return true, nil
}

// Createuser is the resolver for the createuser field.
func (r *mutationResolver) Createuser(ctx context.Context, input model.UserInput) (*model.UserGet, error) {
	panic(fmt.Errorf("not implemented: Createuser - createuser"))
}

// Updateuser is the resolver for the updateuser field.
func (r *mutationResolver) Updateuser(ctx context.Context, input model.UserInput) (*model.UserGet, error) {
	panic(fmt.Errorf("not implemented: Updateuser - updateuser"))
}

// Deleteuser is the resolver for the deleteuser field.
func (r *mutationResolver) Deleteuser(ctx context.Context, id uint) (bool, error) {
	panic(fmt.Errorf("not implemented: Deleteuser - deleteuser"))
}

// Addprojectuser is the resolver for the addprojectuser field.
func (r *mutationResolver) Addprojectuser(ctx context.Context, userID uint, projectID uint) (bool, error) {
	panic(fmt.Errorf("not implemented: Addprojectuser - addprojectuser"))
}

// Deleteprojectuser is the resolver for the deleteprojectuser field.
func (r *mutationResolver) Deleteprojectuser(ctx context.Context, userID uint, projectID uint) (bool, error) {
	panic(fmt.Errorf("not implemented: Deleteprojectuser - deleteprojectuser"))
}

// Projects is the resolver for getting list of projects field.
func (r *queryResolver) Projects(ctx context.Context, page uint, size uint) ([]*model.Project, error) {
	db := r.DB         // Database session for querying
	tracer := r.Tracer // otel collector context and span

	project_get := make([]*model.Project, 0)
	_, result, err := common.PaginationPureModel(db, models.Project{}, []models.Project{}, uint(page), uint(size), tracer.Tracer)
	if err != nil {
		return nil, err
	}
	project := result.([]models.Project)

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(project, &project_get); err != nil {
		return nil, err
	}
	return project_get, nil
}

// Project is the resolver for single project field.
func (r *queryResolver) Project(ctx context.Context, id uint) (*model.Project, error) {
	db := r.DB         // database connection
	tracer := r.Tracer //otel tracer span and context

	var project models.Project    // SQL GORM model
	var project_get model.Project // graphql model

	if res := db.WithContext(tracer.Tracer).Model(&models.Project{}).Preload(clause.Associations).Where("id = ?", uint(id)).First(&project); res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, res.Error
		}
		return nil, res.Error
	}

	// filtering response data according to filtered defined struct
	// return error if anything happens
	if err := mapstructure.Decode(project, &project_get); err != nil {
		return nil, err
	}

	return &project_get, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, page uint, size uint) ([]*model.UserGet, error) {
	panic(fmt.Errorf("not implemented: Users - users"))
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id uint) (*model.UserGet, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
